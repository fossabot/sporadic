var sporadic=function(e){"use strict";var r={defer:()=>{const e={},r={changed:!1};return r.promise=new Promise((r,s)=>{e.resolve=r,e.reject=s}),r.resolve=(s=>{r.changed||(r.changed=!0,e.resolve(s))}),r.reject=(s=>{r.changed||(r.changed=!0,e.reject(s))}),r},resolved:e=>new Promise(r=>r(e)),rejected:e=>new Promise((r,s)=>s(e)),timestamp:()=>(new Date).getTime()};const s=()=>Error("Stream is closed!");let n=null;n=(()=>{const{promise:e,resolve:s,reject:t}=r.defer(),o=e.then(n);return{current:e,next:o,resolve:s,reject:t,produced:!1,broken:!1}});const t=async e=>{return{current:await e.current,next:await e.next}},o=async e=>{let r=e;for(;r.produced&&!r.broken;){const{next:e}=await t(r);r=e}return r};const d=()=>Error("Channel is closed!");let c=null;var l={open:()=>r.resolved(n()),push:async(e,r)=>{const s=await o(e);return s.resolve(r),s.produced=!0,await s.next},pull:t,close:async e=>{const r=await o(e);if(!r.broken)throw r.reject(s()),r.produced=!0,r.broken=!0,s();await r.next}},a={open:()=>r.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=r.defer(),e.isClosed=!1,e})()),send:c=((e,s)=>{if(0===e.demands.length){if(e.isClosed)return r.rejected(d());const n=r.defer();return e.supplies.push({received:n,message:s}),n.promise}{let n=e.demands.shift();for(;e.demands.length>0&&n.changed;)n=e.demands.shift();return n.changed?c(e,s):(n.resolve(s),r.resolved(!0))}}),receive:(e,s)=>{if(0===e.supplies.length){if(e.isClosed)return r.rejected(d());const n=r.defer();return e.demands.push(n),null!=s&&"number"==typeof s&&s>=0&&setTimeout(()=>{n.reject((()=>Error("Timeout while listening channel!"))())},s),n.promise}{const s=e.supplies.shift();return s.received.resolve(!0),r.resolved(s.message)}},close:e=>e.isClosed?r.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(d())})(e),e.closed.resolve(!0),r.resolved(!0)),closed:e=>e.closed.promise},i={streams:l,channels:a};return e.default=i,e.streams=l,e.channels=a,e}({});