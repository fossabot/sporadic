var sporadic=function(e){"use strict";var t={defer:()=>{const e={},t={changed:!1};return t.promise=new Promise((t,s)=>{e.resolve=t,e.reject=s}),t.resolve=(s=>{t.changed||(t.changed=!0,e.resolve(s))}),t.reject=(s=>{t.changed||(t.changed=!0,e.reject(s))}),t},resolved:e=>new Promise(t=>t(e)),rejected:e=>new Promise((t,s)=>s(e)),ignorePromise:e=>e.then(()=>!0).catch(()=>!0)};let s=null;s=(e=>{const{promise:r,resolve:n,reject:a}=t.defer(),o=r.then(()=>s(e));return{current:r,next:o,resolve:n,reject:a,produced:!1,broken:!1,finalizer:e}});const r=async e=>{return{current:await e.current,next:await e.next}},n=async e=>{let t=e;for(;t.produced&&!t.broken;)t=await t.next;return{point:t}},a=async(e,t)=>{const{point:s}=await n(e);return s.resolve(t),s.produced=!0,await s.next},o=async e=>{const{point:t}=await n(e);if(t.broken)await t.next;else{t.reject((()=>Error("Stream is closed!"))()),t.produced=!0,t.broken=!0;try{t.finalizer&&t.finalizer()}catch(e){}await t.next}},l=e=>o(e).catch(()=>{}),i=async(e,s)=>{const n=t.defer();let a=e;try{for(;;){const e=await r(a);a=e.next;try{s(e.current)}catch(e){throw n.reject(e),e}}}catch(e){n.resolve(!0)}return await n.promise};var c={open:e=>t.resolved(s(e)),push:a,pull:r,close:o,react:i,filter:async(e,t)=>{const r=s();let n=r;return i(e,e=>{try{t(e)&&a(n,e).then(e=>{n=e}).catch(e=>{l(n)})}catch(e){l(n)}}).then(()=>{l(n)}),r},map:async(e,t)=>{const r=s();let n=r;return i(e,e=>{try{a(n,t(e)).then(e=>{n=e}).catch(e=>{l(n)})}catch(e){l(n)}}).then(()=>{l(n)}),r},every:e=>{let r=null;const n=s(()=>r());let o=n;const l=setInterval(()=>{a(o,!0).then(e=>{o=e})},e);return r=(()=>{clearInterval(l)}),t.resolved(n)}};const u=()=>Error("Channel is closed!");let d=null,p=null;var h={open:()=>t.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=t.defer(),e.isClosed=!1,e})()),send:d=((e,s,r)=>{if(0===e.demands.length){if(e.isClosed)return t.rejected(u());const n=t.defer();return null!=r&&"number"==typeof r&&r>=1&&setTimeout(()=>{n.resolve(!1)},Math.floor(r)),e.supplies.push({received:n,message:s}),n.promise}{let r=e.demands.shift();for(;e.demands.length>0&&r.changed;)r=e.demands.shift();return r.changed?d(e,s):(r.resolve(s),t.resolved(!0))}}),receive:p=((e,s)=>{if(0===e.supplies.length){if(e.isClosed)return t.rejected(u());const r=t.defer();return e.demands.push(r),null!=s&&"number"==typeof s&&s>=0&&setTimeout(()=>{r.reject((()=>Error("Timeout while listening channel!"))())},Math.floor(s)),r.promise}{let r=e.supplies.shift();for(;e.supplies.length>0&&r.received.changed;)r=e.supplies.shift();return r.received.changed?p(e,s):(r.received.resolve(!0),t.resolved(r.message))}}),close:e=>e.isClosed?t.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(u())})(e),e.closed.resolve(!0),t.resolved(!0)),closed:e=>e.closed.promise,sendAfter:(e,t,s,r)=>new Promise((n,a)=>{setTimeout(()=>{d(t,s,r).then(n,a)},Math.floor(Math.max(0,e)))}),receiveAfter:(e,t,s)=>new Promise((r,n)=>{setTimeout(()=>{p(t,s).then(r,n)},Math.floor(Math.max(0,e)))})};const m=1,f=2,v=3,w=4,y=["<undefined>","CREATED","RUNNING","SUSPENDED","DEAD"],g=async e=>(e.computation=!0,await t.ignorePromise(h.close(e.supply)),await t.ignorePromise(h.close(e.demand)),await t.ignorePromise(c.close(e.demands)),await t.ignorePromise(c.close(e.supplies)),!0);let E=null,j=null,x=null,P=null,C=null,b=null,M=null;E=(async e=>{const s={};s.supplies=await c.open(),s.demands=await c.open(),s.supply=await h.open(),s.demand=await h.open(),s.computation=e,s.status=m,s.result=t.defer();const r={suspend:e=>j(s,e),status:()=>P(s),supplies:()=>b(s),demands:()=>C(s)};return s.computation=e.bind(r),s}),x=(async(e,t)=>{if(!(e&&e.status&&e.computation&&e.demands&&e.supplies&&e.supply&&e.demand&&e.result))throw Error("Expected a valid coroutine!");if(e.status===f)throw Error("Coroutine is already running!");if(e.status===w)throw Error("Coroutine is dead!");await c.push(e.demands,t),e.status===m?(e.status=f,e.computation(t).then(t=>{c.push(e.supplies,t).then(()=>{h.send(e.supply,{value:t,type:"return"})}),e.result.resolve(t)}).catch(t=>{h.send(e.supply,{value:t,type:"error"}),e.result.reject(t)})):(e.status=f,h.send(e.demand,t));const s=await h.receive(e.supply);if("error"===s.type)throw e.status=w,g(e),s.value;return"return"===s.type&&(e.status=w,g(e)),s.value}),j=(async(e,t)=>{if(e.status!==f)throw Error("Expected an active coroutine to yield from!");e.status=v;const s={value:t,type:"suspend"};return await c.push(e.supplies,t),await h.send(e.supply,s),await h.receive(e.demand)});var T=c,D=h,k={create:E,resume:x,status:P=(e=>y[e.status]),supplies:b=(e=>e.supplies),demands:C=(e=>e.demands),complete:M=(e=>e.result.promise)},A={streams:T,channels:D,coroutines:k};return e.default=A,e.streams=T,e.channels=D,e.coroutines=k,e}({});