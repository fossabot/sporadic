var sporadic=function(e){"use strict";var t={defer:()=>{const e={},t={changed:!1};return t.promise=new Promise((t,r)=>{e.resolve=t,e.reject=r}),t.resolve=(r=>{t.changed||(t.changed=!0,e.resolve(r))}),t.reject=(r=>{t.changed||(t.changed=!0,e.reject(r))}),t},resolved:e=>new Promise(t=>t(e)),rejected:e=>new Promise((t,r)=>r(e)),ignorePromise:e=>e.then(()=>!0).catch(()=>!0)};let r=null;r=(e=>{const{promise:s,resolve:n,reject:a}=t.defer(),o=s.then(()=>r(e));return{current:s,next:o,resolve:n,reject:a,produced:!1,broken:!1,finalizer:e}});const s=async e=>{return{current:await e.current,next:await e.next}},n=async e=>{let t=e;for(;t.produced&&!t.broken;)t=await t.next;return{point:t}},a=async(e,t)=>{const{point:r}=await n(e);return r.resolve(t),r.produced=!0,await r.next},o=async e=>{const{point:t}=await n(e);if(t.broken)await t.next;else{t.reject((()=>Error("Stream is closed!"))()),t.produced=!0,t.broken=!0;try{t.finalizer&&t.finalizer()}catch(e){}await t.next}},i=e=>o(e).catch(()=>{}),c=async(e,r)=>{const n=t.defer();let a=e;try{for(;;){const e=await s(a);a=e.next;try{r(e.current)}catch(e){throw n.reject(e),e}}}catch(e){n.resolve(!0)}return await n.promise};var l={open:e=>t.resolved(r(e)),push:a,pull:s,close:o,react:c,filter:async(e,t)=>{const s=r();let n=s;return c(e,e=>{try{t(e)&&a(n,e).then(e=>{n=e}).catch(e=>{i(n)})}catch(e){i(n)}}).then(()=>{i(n)}),s},map:async(e,t)=>{const s=r();let n=s;return c(e,e=>{try{a(n,t(e)).then(e=>{n=e}).catch(e=>{i(n)})}catch(e){i(n)}}).then(()=>{i(n)}),s},every:e=>{let s=null;const n=r(()=>s());let o=n;const i=setInterval(()=>{a(o,!0).then(e=>{o=e})},e);return s=(()=>{clearInterval(i)}),t.resolved(n)}};const d=()=>Error("Channel is closed!");let u=null,p=null;var h={open:()=>t.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=t.defer(),e.isClosed=!1,e})()),send:u=((e,r,s)=>{if(0===e.demands.length){if(e.isClosed)return t.rejected(d());const n=t.defer();return null!=s&&"number"==typeof s&&s>=1&&setTimeout(()=>{n.resolve(!1)},Math.floor(s)),e.supplies.push({received:n,message:r}),n.promise}{let s=e.demands.shift();for(;e.demands.length>0&&s.changed;)s=e.demands.shift();return s.changed?u(e,r):(s.resolve(r),t.resolved(!0))}}),receive:p=((e,r)=>{if(0===e.supplies.length){if(e.isClosed)return t.rejected(d());const s=t.defer();return e.demands.push(s),null!=r&&"number"==typeof r&&r>=0&&setTimeout(()=>{s.reject((()=>Error("Timeout while listening channel!"))())},Math.floor(r)),s.promise}{let s=e.supplies.shift();for(;e.supplies.length>0&&s.received.changed;)s=e.supplies.shift();return s.received.changed?p(e,r):(s.received.resolve(!0),t.resolved(s.message))}}),close:e=>e.isClosed?t.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(d())})(e),e.closed.resolve(!0),t.resolved(!0)),closed:e=>e.closed.promise,sendAfter:(e,t,r,s)=>new Promise((n,a)=>{setTimeout(()=>{u(t,r,s).then(n,a)},Math.floor(Math.max(0,e)))}),receiveAfter:(e,t,r)=>new Promise((s,n)=>{setTimeout(()=>{p(t,r).then(s,n)},Math.floor(Math.max(0,e)))})};const m=1,f=2,v=3,w=4,y=["<undefined>","CREATED","RUNNING","SUSPENDED","DEAD"],g=[],j=e=>{if(!e)return g.pop();g.push(e)},P=async e=>(e.computation=null,await t.ignorePromise(h.close(e.supply)),await t.ignorePromise(h.close(e.demand)),await t.ignorePromise(l.close(e.demands)),await t.ignorePromise(l.close(e.supplies)),!0);var x=async e=>{const r={};return r.supplies=await l.open(),r.demands=await l.open(),r.supply=await h.open(),r.demand=await h.open(),r.computation=e,r.status=m,r.result=t.defer(),r},E=async(e,t)=>{if(j(e),e.status===f)throw Error("Coroutine is already running!");if(e.status===w)throw Error("Coroutine is dead!");await l.push(e.supplies,t),e.status===m?(e.status=f,e.computation(t).then(t=>{l.push(e.demands,t).then(()=>{h.send(e.demand,{value:t,type:"return"})}),e.result.resolve(t)}).catch(t=>{h.send(e.demand,{value:t,type:"error"}),e.result.reject(t)})):(e.status=f,h.send(e.supply,t));const r=await h.receive(e.demand);if("error"===r.type)throw e.status=w,P(e),r.value;return"return"===r.type&&(e.status=w,P(e)),r.value},C=async e=>{const t=j();t.status=v;const r={value:e,type:"suspend"};return await l.push(t.demands,e),await h.send(t.demand,r),await h.receive(t.supply)},b=l,M=h,T={create:x,resume:E,status:e=>y[e.status],suspend:C,supplies:e=>e.supplies,demands:e=>e.demands,complete:e=>e.result.promise},D={streams:b,channels:M,coroutines:T};return e.default=D,e.streams=b,e.channels=M,e.coroutines=T,e}({});