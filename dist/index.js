var sporadic=function(e){"use strict";var r={defer:()=>{const e={},r={changed:!1};return r.promise=new Promise((r,s)=>{e.resolve=r,e.reject=s}),r.resolve=(s=>{r.changed||(r.changed=!0,e.resolve(s))}),r.reject=(s=>{r.changed||(r.changed=!0,e.reject(s))}),r},resolved:e=>new Promise(r=>r(e)),rejected:e=>new Promise((r,s)=>s(e))};const s=()=>Error("Stream is closed!");let t=null;t=(()=>{const{promise:e,resolve:s,reject:n}=r.defer(),o=e.then(t);return{current:e,next:o,resolve:s,reject:n,produced:!1,broken:!1}});const n=async e=>{return{current:await e.current,next:await e.next}},o=async e=>{let r=e;for(;r.produced&&!r.broken;){const{next:e}=await n(r);r=e}return r};const l=()=>Error("Channel is closed!");let d=null,c=null;var a={open:()=>r.resolved(t()),push:async(e,r)=>{const s=await o(e);return s.resolve(r),s.produced=!0,await s.next},pull:n,close:async e=>{const r=await o(e);if(!r.broken)throw r.reject(s()),r.produced=!0,r.broken=!0,s();await r.next}},i={open:()=>r.resolved((()=>{const e={demands:[],supplies:[]};return e.closed=r.defer(),e.isClosed=!1,e})()),send:d=((e,s,t)=>{if(0===e.demands.length){if(e.isClosed)return r.rejected(l());const n=r.defer();return null!=t&&"number"==typeof t&&t>=1&&setTimeout(()=>{n.resolve(!1)},Math.floor(t)),e.supplies.push({received:n,message:s}),n.promise}{let t=e.demands.shift();for(;e.demands.length>0&&t.changed;)t=e.demands.shift();return t.changed?d(e,s):(t.resolve(s),r.resolved(!0))}}),receive:c=((e,s)=>{if(0===e.supplies.length){if(e.isClosed)return r.rejected(l());const t=r.defer();return e.demands.push(t),null!=s&&"number"==typeof s&&s>=0&&setTimeout(()=>{t.reject((()=>Error("Timeout while listening channel!"))())},Math.floor(s)),t.promise}{let t=e.supplies.shift();for(;e.supplies.length>0&&t.received.changed;)t=e.supplies.shift();return t.received.changed?c(e,s):(t.received.resolve(!0),r.resolved(t.message))}}),close:e=>e.isClosed?r.resolved(!1):(e.isClosed=!0,(e=>{for(;0!==e.demands.length;)e.demands.shift().reject(l())})(e),e.closed.resolve(!0),r.resolved(!0)),closed:e=>e.closed.promise,sendAfter:(e,r,s,t)=>new Promise((n,o)=>{setTimeout(()=>{d(r,s,t).then(n).catch(o)},Math.floor(Math.max(0,e)))}),receiveAfter:(e,r,s)=>new Promise((t,n)=>{setTimeout(()=>{c(r,s).then(t).catch(n)},Math.floor(Math.max(0,e)))})},u={streams:a,channels:i};return e.default=u,e.streams=a,e.channels=i,e}({});